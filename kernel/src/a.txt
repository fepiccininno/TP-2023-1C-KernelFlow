#include "kernel.h"

#define MAX_CLIENTS 10

sem_t* semaforo;

int main(int argc, char *argv[])
{
   char *ip_memoria;
   char *puerto_memoria;
   char *ip_filesystem;
   char *puerto_filesystem;
   char *ip_cpu;
   char *puerto_cpu;
   char *puerto_escucha;

   char *config_path = string_new();
   string_append(&config_path, "/home/utnso/Desktop/tp-2023-1c-KernelFlow/kernel/conf/kernel.config");

   t_log *main_logger;

   main_logger = log_create("/home/utnso/Desktop/tp-2023-1c-KernelFlow/kernel/logs/kernel.log", "KERNEL", true, LOG_LEVEL_INFO);
   logger = log_create("/home/utnso/Desktop/tp-2023-1c-KernelFlow/kernel/logs/kernel_aux.log", "KERNEL AUX", true, LOG_LEVEL_DEBUG);

   // Leer el archivo de configuración
   t_config *config;
   config = read_config(config_path);

   // Cliente
   ip_memoria = config_get_string_value(config, "IP_MEMORIA");
   puerto_memoria = config_get_string_value(config, "PUERTO_MEMORIA");
   // Cliente
   ip_filesystem = config_get_string_value(config, "IP_FILESYSTEM");
   puerto_filesystem = config_get_string_value(config, "PUERTO_FILESYSTEM");
   // Cliente
   ip_cpu = config_get_string_value(config, "IP_CPU");
   puerto_cpu = config_get_string_value(config, "PUERTO_CPU");
   // Servidor
   puerto_escucha = config_get_string_value(config, "PUERTO_ESCUCHA");

   // Iniciar el servidor
   semaforo = sem_open("/semaforo", O_CREAT, 0666, 1);
   if (semaforo == SEM_FAILED)
   {
      perror("sem_open");
      exit(EXIT_FAILURE);
   }

   int server_fd = start_server(puerto_escucha);

   while (1)
   {
      // Esperar a que llegue un nuevo cliente
      int cliente_fd = wait_client(server_fd);

      // Crear un nuevo proceso hijo para manejar la conexión del cliente
      pid_t pid = fork();
      if (pid == -1)
      {
         perror("fork");
         exit(EXIT_FAILURE);
      }
      else if (pid == 0)
      {
         // Proceso hijo
         sem_wait(semaforo);
         handle_client(cliente_fd);
         sem_post(semaforo);
         exit(EXIT_SUCCESS);
      }
      else
      {
         // Proceso padre
         client_destroy(cliente_fd);
      }
   }

   // Cerrar el socket del servidor
   server_destroy(server_fd);

   // Cerrar el semáforo
   sem_close(semaforo);
   sem_unlink("/semaforo");

   end_kernel(ip_memoria, puerto_memoria, ip_filesystem, puerto_filesystem, ip_cpu, puerto_cpu, puerto_escucha, config, logger, main_logger);

   return EXIT_SUCCESS;
}


t_config *read_config(char* config_path)
{
   t_config *new_config;
   new_config = config_create(config_path);
   return new_config;
}

void iterator(char *value)
{
   log_info(logger, "%s", value);
}

void handle_client(int cliente_fd)
{
   t_list *lista;
   while (1)
   {
      int cod_op = get_operation(cliente_fd);
      switch (cod_op)
      {
      case MENSAJE:
         get_message(cliente_fd);
         break;
      case PAQUETE:
         lista = get_package(cliente_fd);
         log_info(logger, "Me llegaron los siguientes valores:\n");
         list_iterate(lista, (void *)iterator);
         break;
      case -1:
         log_error(logger, "el cliente se desconecto. Terminando servidor");
         close(cliente_fd);
         exit(EXIT_FAILURE);
      default:
         log_warning(logger, "Operacion desconocida. No quieras meter la pata");
         break;
      }
   }
}

void end_kernel(char *ip_memoria, char *puerto_memoria, char *ip_filesystem, char *puerto_filesystem, char *ip_cpu, char *puerto_cpu, char *puerto_escucha, t_config *config, t_log *logger, t_log *main_logger)
{
   log_info(logger, "Terminando kernel");

   free(ip_memoria);
   free(puerto_memoria);
   free(ip_filesystem);
   free(puerto_filesystem);
   free(ip_cpu);
   free(puerto_cpu);
   free(puerto_escucha);

   config_destroy(config);

   log_destroy(main_logger);
   log_destroy(logger);
}